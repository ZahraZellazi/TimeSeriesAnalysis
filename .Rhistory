# Supprimer les NA restants si présents
data <- data %>% drop_na(Value)
# Étape 6 : Créer une tsibble
data_tsibble <- data%>%
mutate(Period = yearmonth(Period)) %>%
as_tsibble(index = Period)
# Étape 7 : Visualisation
ggplot(data_tsibble, aes(x = Period, y = Value)) +
geom_line(color = "darkblue") +
labs(title = "Dépenses mensuelles de construction aux États-Unis",
x = "Date", y = "Dépenses (Millions de $)") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Étape 8 : Création d’un objet ts
construction_ts <- ts(data$Value, start = c(2002, 1), frequency = 12)
plot(construction_ts,
main = "Série temporelle des dépenses de construction (ts)",
ylab = "Dépenses (Millions de $)", xlab = "Année", col = "darkblue")
# Étape 9 : Zoom sur 2015–2020
construction_zoom <- window(construction_ts, start = c(2015, 1), end = c(2020, 12))
plot(construction_zoom, col = "darkred", lwd = 2,
main = "Zoom : Dépenses de construction (2015–2020)",
ylab = "Dépenses (Millions de $)", xlab = "Années",
xaxt = "n")
axis(1, at = seq(2015, 2020, by = 1), labels = seq(2015, 2020, by = 1))
# Étape 10 : Statistiques descriptives
mean_value <- mean(construction_ts)
var_value <- var(construction_ts)
std_value <- sd(construction_ts)
cat("Moyenne:", mean_value, "\n")
cat("Variance:", var_value, "\n")
cat("Écart-type:", std_value, "\n")
# Étape 11 : Décomposition multiplicative
decomp_multiplicative <- decompose(construction_ts, type = "multiplicative")
plot(decomp_multiplicative)
# Étape 12 : Autocorrélation
lag.plot(construction_ts, lags = 36)
# Calcul de l'autocorrélation (ACF)
acf(construction_ts)
# Ajustement par moyenne mobile (k=12 pour saisonnalité mensuelle)
mm <- stats::filter(construction_ts, rep(1/12, 12), sides = 2)
plot(construction_ts, col = "gray", main = "Ajustement par moyenne mobile")
lines(mm, col = "blue", lwd = 2)
legend("topleft", legend = c("Série Originale", "Moyenne Mobile"), col = c("gray", "blue"), lty = 1)
summary(mm)
# Ajustement de la composante saisonnaire
t <- 1:length(construction_ts)  # Création du vecteur temps
# Initialisation des matrices pour les termes cosinus et sinus
Mc <- matrix(0, nrow = length(construction_ts), ncol = 6)  # 6 termes cosinus
Ms <- matrix(0, nrow = length(construction_ts), ncol = 6)  # 6 termes sinus
# Remplissage des matrices avec les termes harmoniques
for (i in 1:6) {
Mc[, i] <- cos(2 * pi * t * i / 12)  # Termes cosinus
Ms[, i] <- sin(2 * pi * t * i / 12)  # Termes sinus
}
# Construction du modèle de régression avec les termes harmoniques
harm_model <- lm(construction_ts ~ Mc + Ms)
# Résumé du modèle
summary(harm_model)
# Création du vecteur temps
t <- 1:length(construction_ts)
# Nombre optimal de termes harmoniques (ici 3 pour éviter le surajustement)
k <- 3
# Initialisation des matrices pour les termes cosinus et sinus
Mc <- matrix(0, nrow = length(construction_ts), ncol = k)
Ms <- matrix(0, nrow = length(construction_ts), ncol = k)
# Remplissage des matrices avec les termes harmoniques
for (i in 1:k) {
Mc[, i] <- cos(2 * pi * t * i / 12)
Ms[, i] <- sin(2 * pi * t * i / 12)
}
# Modèle de régression avec tendance linéaire et composante saisonnière
harm_model <- lm(construction_ts ~ t + Mc + Ms)
# Résumé du modèle
summary(harm_model)
# Ajustement de la composante saisonnaire
t <- 1:length(construction_ts)  # Création du vecteur temps
# Initialisation des matrices pour plus de termes
Mc <- matrix(0, nrow = length(construction_ts), ncol = 12)  # 12 termes cosinus
Ms <- matrix(0, nrow = length(construction_ts), ncol = 12)  # 12 termes sinus
# Remplissage des matrices avec les termes harmoniques
for (i in 1:12) {
Mc[, i] <- cos(2 * pi * t * i / 12)  # Termes cosinus
Ms[, i] <- sin(2 * pi * t * i / 12)  # Termes sinus
}
# Construction du modèle de régression avec les nouveaux termes
harm_model <- lm(construction_ts ~ t + Mc + Ms)
summary(harm_model)
# Ajustement de la composante saisonnaire
t <- 1:length(construction_ts)  # Création du vecteur temps
# Initialisation des matrices pour les termes cosinus et sinus
Mc <- matrix(0, nrow = length(construction_ts), ncol = 6)  # 6 termes cosinus
Ms <- matrix(0, nrow = length(construction_ts), ncol = 6)  # 6 termes sinus
# Remplissage des matrices avec les termes harmoniques
for (i in 1:6) {
Mc[, i] <- cos(2 * pi * t * i / 12)  # Termes cosinus
Ms[, i] <- sin(2 * pi * t * i / 12)  # Termes sinus
}
# Construction du modèle de régression avec les termes harmoniques
harm_model <- lm(construction_ts ~ Mc + Ms)
# Résumé du modèle
summary(harm_model)
# Test de stationnarité
adf_result <- adf.test(construction_ts)
cat("Résultat du test ADF: \n")
print(adf_result)
# Si la série n'est pas stationnaire, appliquer une différenciation d'ordre 1
construction_diff <- diff(construction_ts)
plot(construction_diff, main = "Série différenciée d'ordre 1")
acf(construction_diff, main = "ACF de la série différenciée")
pacf(construction_diff, main = "PACF de la série différenciée")
# Modèle ARIMA automatique
modele_auto <- auto.arima(construction_ts)
summary(modele_auto)
# Test de Ljung-Box sur les résidus du modèle
residus <- residuals(modele_auto)
Box.test(residus, lag = 20, type = "Ljung-Box")
checkresiduals(modele_auto)
# Prévision des 12 prochains mois
prevision <- forecast(modele_auto, h = 40)
plot(prevision, main = "Prévision des dépenses de construction")
# Résumé du modèle
summary(harm_model)
# Création du vecteur temps
t <- 1:length(construction_ts)
# Augmenter le nombre de termes cosinus et sinus
n_terms <- 12
Mc <- matrix(0, nrow = length(construction_ts), ncol = n_terms)  # 12 termes cosinus
Ms <- matrix(0, nrow = length(construction_ts), ncol = n_terms)  # 12 termes sinus
# Remplissage des matrices avec les termes harmoniques
for (i in 1:n_terms) {
Mc[, i] <- cos(2 * pi * t * i / 12)  # Termes cosinus
Ms[, i] <- sin(2 * pi * t * i / 12)  # Termes sinus
}
# Vérification de la multicolinéarité avec le VIF
vif_model <- lm(construction_ts ~ Mc + Ms)
vif_values <- vif(vif_model)
print(vif_values)
# Centrer et réduire les matrices de termes cosinus et sinus
Mc_centered <- scale(Mc)
Ms_centered <- scale(Ms)
# Construction du modèle de régression avec les termes harmoniques centrés
harm_model <- lm(construction_ts ~ Mc_centered + Ms_centered)
# Résumé du modèle
summary(harm_model)
# Création du vecteur temps
t <- 1:length(construction_ts)
# Augmenter le nombre de termes cosinus et sinus (12 termes ici)
n_terms <- 12
Mc <- matrix(0, nrow = length(construction_ts), ncol = n_terms)
Ms <- matrix(0, nrow = length(construction_ts), ncol = n_terms)
# Remplissage des matrices avec les termes harmoniques
for (i in 1:n_terms) {
Mc[, i] <- cos(2 * pi * t * i / 12)  # Termes cosinus
Ms[, i] <- sin(2 * pi * t * i / 12)  # Termes sinus
}
# Construction du modèle de régression avec les termes harmoniques
harm_model <- lm(construction_ts ~ Mc + Ms)
# Résumé du modèle
summary(harm_model)
# Ajustement de la composante saisonnaire
t <- 1:length(construction_ts)  # Création du vecteur temps
# Initialisation des matrices pour les termes cosinus et sinus
Mc <- matrix(0, nrow = length(construction_ts), ncol = 6)  # 6 termes cosinus
Ms <- matrix(0, nrow = length(construction_ts), ncol = 6)  # 6 termes sinus
# Remplissage des matrices avec les termes harmoniques
for (i in 1:6) {
Mc[, i] <- cos(2 * pi * t * i / 12)  # Termes cosinus
Ms[, i] <- sin(2 * pi * t * i / 12)  # Termes sinus
}
# Construction du modèle de régression avec les termes harmoniques
harm_model <- lm(construction_ts ~ Mc + Ms)
# Résumé du modèle
summary(harm_model)
# Ajustement de la composante saisonnaire
t <- 1:length(construction_ts)  # Création du vecteur temps
# Initialisation des matrices pour les termes cosinus et sinus
# Augmenter encore le nombre de termes cosinus et sinus (par exemple à 18)
n_terms <- 18
Mc <- matrix(0, nrow = length(construction_ts), ncol = n_terms)
Ms <- matrix(0, nrow = length(construction_ts), ncol = n_terms)
# Remplissage des matrices avec les termes harmoniques
for (i in 1:n_terms) {
Mc[, i] <- cos(2 * pi * t * i / 12)  # Termes cosinus
Ms[, i] <- sin(2 * pi * t * i / 12)  # Termes sinus
}
# Construction du modèle de régression avec les nouveaux termes
harm_model <- lm(construction_ts ~ Mc + Ms)
# Résumé du modèle
summary(harm_model)
# Ajustement de la composante saisonnaire
t <- 1:length(construction_ts)  # Création du vecteur temps
# Initialisation des matrices pour les termes cosinus et sinus
Mc <- matrix(0, nrow = length(construction_ts), ncol = 6)  # 6 termes cosinus
Ms <- matrix(0, nrow = length(construction_ts), ncol = 6)  # 6 termes sinus
# Remplissage des matrices avec les termes harmoniques
for (i in 1:6) {
Mc[, i] <- cos(2 * pi * t * i / 12)  # Termes cosinus
Ms[, i] <- sin(2 * pi * t * i / 12)  # Termes sinus
}
# Construction du modèle de régression avec les termes harmoniques
harm_model <- lm(construction_ts ~ Mc + Ms)
# Résumé du modèle
summary(harm_model)
# Test de stationnarité
adf_result <- adf.test(construction_ts)
# Liste des packages nécessaires
packages <- c(
"tidyverse", "lubridate", "forecast", "tseries",
"urca", "tsibble", "feasts", "readxl", "patchwork",
"fable", "knitr", "xts"
)
# Installation et chargement des packages
for (pkg in packages) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg, dependencies = TRUE)
}
library(pkg, character.only = TRUE)
}
# Charger le fichier avec skip pour ignorer les métadonnées
production_electronique <- read_excel(file.choose(), skip = 10)
production_electronique$observation_date <- as.Date(production_electronique$observation_date)
head(production_electronique)
tail(production_electronique)
str(production_electronique)
summary(production_electronique)
# Étape 1 : Packages nécessaires
packages <- c(
"tidyverse", "lubridate", "forecast", "tseries",
"urca", "tsibble", "feasts", "readxl", "patchwork",
"fable", "knitr", "xts", "moments", "zoo"
)
# Étape 2 : Installer/charger les packages
for (pkg in packages) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, dependencies = TRUE)
library(pkg, character.only = TRUE)
} else {
library(pkg, character.only = TRUE)
}
}
# Étape 3 : Lire le fichier Excel
data <- read_excel(file.choose(), skip = 7)
# Étape 4 : Nettoyage et renommage des colonnes
# Pour dates Excel stockées en format numérique
if (is.numeric(data$Period)) {
data <- data %>%
rename(Period = 1, Value = 2) %>%
mutate(Period = as.Date(Period, origin = "1899-12-30"))
} else {
data <- data %>%
rename(Period = 1, Value = 2) %>%
mutate(Period = lubridate::parse_date_time(Period, orders = c("ymd", "my", "bY", "mY")))
}
# Étape 5 : Interpolation des valeurs manquantes
data$Value <- zoo::na.approx(data$Value, na.rm = FALSE)
# Supprimer les NA restants si présents
data <- data %>% drop_na(Value)
# Étape 6 : Créer une tsibble
data_tsibble <- data%>%
mutate(Period = yearmonth(Period)) %>%
as_tsibble(index = Period)
# Étape 7 : Visualisation
ggplot(data_tsibble, aes(x = Period, y = Value)) +
geom_line(color = "darkblue") +
labs(title = "Dépenses mensuelles de construction aux États-Unis",
x = "Date", y = "Dépenses (Millions de $)") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Étape 8 : Création d’un objet ts
construction_ts <- ts(data$Value, start = c(2002, 1), frequency = 12)
plot(construction_ts,
main = "Série temporelle des dépenses de construction (ts)",
ylab = "Dépenses (Millions de $)", xlab = "Année", col = "darkblue")
# Étape 9 : Zoom sur 2015–2020
construction_zoom <- window(construction_ts, start = c(2015, 1), end = c(2020, 12))
plot(construction_zoom, col = "darkred", lwd = 2,
main = "Zoom : Dépenses de construction (2015–2020)",
ylab = "Dépenses (Millions de $)", xlab = "Années",
xaxt = "n")
axis(1, at = seq(2015, 2020, by = 1), labels = seq(2015, 2020, by = 1))
# Étape 10 : Statistiques descriptives
mean_value <- mean(construction_ts)
var_value <- var(construction_ts)
std_value <- sd(construction_ts)
cat("Moyenne:", mean_value, "\n")
cat("Variance:", var_value, "\n")
cat("Écart-type:", std_value, "\n")
head(construction_ts)
tail(construction_ts)
str(construction_ts)
summary(construction_ts)
class(construction_ts)
# Liste des packages nécessaires
packages <- c(
"tidyverse", "lubridate", "forecast", "tseries",
"urca", "tsibble", "feasts", "readxl", "patchwork",
"fable", "knitr", "xts"
)
# Installation et chargement des packages
for (pkg in packages) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg, dependencies = TRUE)
}
library(pkg, character.only = TRUE)
}
# Charger le fichier avec skip pour ignorer les métadonnées
production_electronique <- read_excel(file.choose(), skip = 10)
production_electronique$observation_date <- as.Date(production_electronique$observation_date)
head(production_electronique)
tail(production_electronique)
str(production_electronique)
summary(production_electronique)
class(production_electronique)
#serie_ts
# Créer une série temporelle avec fréquence mensuelle
production_electronique_ts <- ts(production_electronique$IPB53122N,
start = c(2009, 1),  # Début en janvier 2009
frequency = 12)      # Fréquence mensuelle
# Afficher les premières lignes de la série multivariée
head(production_electronique_ts)
# Vérifiez la série temporelle
class(production_electronique_ts)
#Visualisation
plot(production_electronique_ts,
main = "Production industrielle électronique (2009-2024)",
ylab = "Index IPB53122N", xlab = "Année",
col = "blue", lwd = 2)
# serie_xts
Date<-seq(as.Date("2009/01/01"), as.Date("2024/03/01"),by="months")
production_electronique_xts <- xts(production_electronique$IPB53122N, order.by = Date)
class(production_electronique_xts)
plot(production_electronique_xts,
main = "Production industrielle électronique (2009-2024)",
ylab = "Index IPB53122N", xlab = "Année",
col = "pink", lwd = 2)
# Sélectionner une sous-série de 2010 à 2012
zoom_production <- window(production_electronique_ts, start=c(2010, 1), end=c(2013, 12))
# Tracer la sous-série
plot(zoom_production,  ylab="Production", xlab="Année",  col = "green")
# Tracer la sous-série
plot(zoom_production,  ylab="Production", xlab="Année",  col = "green")
# Résumé statistique
summary(production_electronique_ts)
# Moyenne
mean(production_electronique_ts)
# Variance
var(production_electronique_ts)
# Écart-type
sd(production_electronique_ts)
# Décomposition de la série temporelle
decomp <- decompose(production_electronique_ts, type = "multiplicative")
# Afficher les composants de la décomposition
decomp
# Afficher la tendance
decomp$trend
# Afficher la saisonnalité
decomp$seasonal
decomp$random
plot(decomp)
# Autocorrelation :
lag.plot(production_electronique_ts , lags=36)
# Calcul de l'autocorrélation (ACF)
acf(production_electronique_ts)
# Autocorrelation :
lag.plot(production_electronique_ts , lags=36)
# Calcul de l'autocorrélation (ACF)
acf(production_electronique_ts)
acf(production_electronique_ts, plot=F )
# Lissage par moyenne mobile (k=12 pour saisonnalité mensuelle)
mm <- stats::filter(production_electronique_ts, filter = rep(1/12, 12), sides = 2)
plot(production_electronique_ts, col = "gray", main = "Ajustement par moyenne mobile")
lines(mm, col = "blue", lwd = 2)
legend("topleft", legend = c("Série Originale", "Moyenne Mobile"), col = c("gray", "blue"), lty = 1)
summary(mm)
# Lissage lm
temps <- time(production_electronique_ts)
modele_lm <- lm(production_electronique_ts ~ temps)
summary(modele_lm)
plot(production_electronique_ts, main="Ajustement linéaire", col="gray")
abline(modele_lm, col="red", lwd=2)
# Création du modèle polynomial (degré 2)
temps <- time(production_electronique_ts)
modele_poly <- lm(production_electronique_ts ~ poly(temps, 2, raw = TRUE))
# Résumé du modèle
summary(modele_poly)
# Création du modèle polynomial (degré 2)
temps <- time(production_electronique_ts)
modele_poly <- lm(production_electronique_ts ~ poly(temps, 2, raw = TRUE))
# Résumé du modèle
summary(modele_poly)
# Créer un data frame propre avec les valeurs ajustées
df <- data.frame(
temps = as.numeric(temps),
production = as.numeric(production_electronique_ts),
ajuste = fitted(modele_poly)
)
# Tracer la série originale
plot(df$temps, df$production, type = "l", col = "gray",
main = "Ajustement polynomial (degré 2)", xlab = "Temps", ylab = "Production")
# Ajouter la courbe ajustée
lines(df$temps, df$ajuste, col = "blue", lwd = 2)
# Légende
legend("topleft", legend = c("Série", "Ajustement polynôme d'ordre 2"),
col = c("gray", "blue"), lty = 1)
# Création du vecteur temporel
t <- 1:length(production_electronique_ts)
# Nombre de termes harmoniques (k = 3 pour éviter le surajustement)
k <- 3
# Initialisation des matrices cosinus et sinus
Mc <- matrix(0, nrow = length(production_electronique_ts), ncol = k)
Ms <- matrix(0, nrow = length(production_electronique_ts), ncol = k)
# Remplissage des matrices avec les termes harmoniques
for (i in 1:k) {
Mc[, i] <- cos(2 * pi * t * i / 12)
Ms[, i] <- sin(2 * pi * t * i / 12)
}
# Modèle de régression harmonique avec tendance linéaire
harm_model <- lm(production_electronique_ts ~ t + Mc + Ms)
# Résumé du modèle
summary(harm_model)
# Prévision basée sur le modèle ajusté
fitted_values <- predict(harm_model)
# Affichage des résultats
plot(t, production_electronique_ts, type = "l", col = "blue",
xlab = "Temps", ylab = "Production électronique",
main = "Ajustement de la régression harmonique avec tendance linéaire")
lines(t, fitted_values, col = "red", lwd = 2)
legend("topright", legend = c("Données observées", "Ajustement"),
col = c("blue", "red"), lty = c(1, 1), lwd = c(1, 2))
adf.test(production_electronique_ts)  # Test de Dickey-Fuller (ADF)
# Appliquer une différenciation d'ordre 1
production_electronique_diff <- diff(production_electronique_ts)
# Afficher la série différenciée
plot(production_electronique_diff, main = "Série différenciée d'ordre 1")
acf(production_electronique_diff, main = "ACF de la série différenciée")
# Afficher la série différenciée
plot(production_electronique_diff, main = "Série différenciée d'ordre 1")
acf(production_electronique_diff, main = "ACF de la série différenciée")
pacf(production_electronique_diff, main = "PACF de la série différenciée")
library(forecast)
modele_auto <- auto.arima(production_electronique_ts)
summary(modele_auto)
# Test de Ljung-Box sur les résidus du modèle
residus <- residuals(modele_auto)
stats::Box.test(residus, lag = 20, type = "Ljung-Box")
# Prévoir les 12 prochains mois
prevision <- forecast(modele_auto, h = 12)
# Afficher les résultats
plot(prevision, main = "Prévision de la production électronique")
prevision
checkresiduals(modele_auto)
# Étape 1 : Packages nécessaires
packages <- c(
"tidyverse", "lubridate", "forecast", "tseries",
"urca", "tsibble", "feasts", "readxl", "patchwork",
"fable", "knitr", "xts", "moments", "zoo"
)
# Étape 2 : Installer/charger les packages
for (pkg in packages) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, dependencies = TRUE)
library(pkg, character.only = TRUE)
} else {
library(pkg, character.only = TRUE)
}
}
# Étape 3 : Lire le fichier Excel
data <- read_excel(file.choose(), skip = 7)
# Étape 1 : Packages nécessaires
packages <- c(
"tidyverse", "lubridate", "forecast", "tseries",
"urca", "tsibble", "feasts", "readxl", "patchwork",
"fable", "knitr", "xts", "moments", "zoo"
)
# Étape 2 : Installer/charger les packages
for (pkg in packages) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, dependencies = TRUE)
library(pkg, character.only = TRUE)
} else {
library(pkg, character.only = TRUE)
}
}
# Étape 3 : Lire le fichier Excel
data <- read_excel(file.choose(), skip = 7)
# Étape 4 : Nettoyage et renommage des colonnes
# Pour dates Excel stockées en format numérique
if (is.numeric(data$Period)) {
data <- data %>%
rename(Period = 1, Value = 2) %>%
mutate(Period = as.Date(Period, origin = "1899-12-30"))
} else {
data <- data %>%
rename(Period = 1, Value = 2) %>%
mutate(Period = lubridate::parse_date_time(Period, orders = c("ymd", "my", "bY", "mY")))
}
# Étape 5 : Interpolation des valeurs manquantes
data$Value <- zoo::na.approx(data$Value, na.rm = FALSE)
# Supprimer les NA restants si présents
data <- data %>% drop_na(Value)
# Étape 6 : Créer une tsibble
data_tsibble <- data%>%
mutate(Period = yearmonth(Period)) %>%
as_tsibble(index = Period)
# Étape 7 : Visualisation
ggplot(data_tsibble, aes(x = Period, y = Value)) +
geom_line(color = "darkblue") +
labs(title = "Dépenses mensuelles de construction aux États-Unis",
x = "Date", y = "Dépenses (Millions de $)") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
